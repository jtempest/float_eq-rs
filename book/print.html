<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Documentation for float_eq 1.0.1</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">2.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/basic_usage.html"><strong aria-hidden="true">2.1.</strong> Basic usage</a></li></ol></li><li class="chapter-item expanded "><a href="how_to.html"><strong aria-hidden="true">3.</strong> How to</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="how_to/compare_floating_point_numbers.html"><strong aria-hidden="true">3.1.</strong> Compare floating point numbers</a></li><li class="chapter-item expanded "><a href="how_to/compare_composite_types.html"><strong aria-hidden="true">3.2.</strong> Compare composite types</a></li><li class="chapter-item expanded "><a href="how_to/interpret_assert_failure_messages.html"><strong aria-hidden="true">3.3.</strong> Interpret assert failure messages</a></li><li class="chapter-item expanded "><a href="how_to/compare_custom_types.html"><strong aria-hidden="true">3.4.</strong> Compare custom types</a></li><li class="chapter-item expanded "><a href="how_to/derive_the_traits.html"><strong aria-hidden="true">3.5.</strong> Derive the traits</a></li><li class="chapter-item expanded "><a href="how_to/manually_implement_the_traits.html"><strong aria-hidden="true">3.6.</strong> Manually implement the traits</a></li></ol></li><li class="chapter-item expanded "><a href="background.html"><strong aria-hidden="true">4.</strong> Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="background/float_comparison_algorithms.html"><strong aria-hidden="true">4.1.</strong> Float comparison algorithms</a></li><li class="chapter-item expanded "><a href="background/resources.html"><strong aria-hidden="true">4.2.</strong> Resources</a></li></ol></li><li class="chapter-item expanded "><a href="api_documentation.html"><strong aria-hidden="true">5.</strong> API documentation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Documentation for float_eq 1.0.1</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://floating-point-gui.de/formats/fp/">Floating point types</a> have <a href="https://www.exploringbinary.com/floating-point-questions-are-endless-on-stackoverflow-com/">a reputation</a> for being <a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">difficult to use</a> compared
to integer types. This is partly because they have unintuitive sources of
rounding error but it also stems from the kinds of calculations they are used
for, which contain plentiful other sources of <a href="https://en.wikipedia.org/wiki/Numerical_error">numeric error</a>.</p>
<p>The <a href="http://crates.io/crates/float_eq">float_eq</a> crate provides an API for comparing floating point primitives,
structs and collections for equality that allows users to communicate their
reasoning and intent with respect to numeric error.</p>
<p>This guide is not designed to be read from cover to cover, but instead is a
series of categorised articles. If you are unsure of how floats work or why they
are considered difficult to use then begin with the <a href="./tutorials/basic_usage.html">Basic Usage</a>
guide, otherwise check out one of the categories for more:</p>
<ul>
<li><a href="./tutorials.html">Tutorials</a>: getting started.</li>
<li><a href="./how_to.html">How to guides</a>: solutions to specific problems.</li>
<li><a href="./background.html">Background</a>: explanation and discussion.</li>
<li><a href="./api_documentation.html">API documentation</a>: detailed technical reference.</li>
</ul>
<hr />
<p>Thanks go to everyone who has provided feedback and patiently answered my questions, particularly Robin Leroy. This guide's structure was inspired by the <a href="https://diataxis.fr/">Diátaxis Framework</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<ul>
<li><a href="./tutorials/basic_usage.html">Basic Usage</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h1>
<p>So you have attempted to perform a simple floating point calculation in Rust,
perhaps an <a href="https://0.30000000000000004.com/">old classic</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = 0.1 + 0.2;

if sum == 0.3 {
    println!(&quot;Decimal math is working as expected!&quot;);
} else {
    println!(&quot;Something has gone horribly wrong!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>And it turns out that:</p>
<pre><code class="language-txt">Something has gone horribly wrong!
</code></pre>
<p>What's going on? Let's take a closer look at the result of the sum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;0.1 + 0.2 = {}&quot;, sum);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">0.1 + 0.2 = 0.30000000000000004
</code></pre>
<p>That doesn't seem like the right answer at all! It's very close, but why is it
off by a tiny amount?</p>
<p>Well, what's happened is that the <code>f64</code> type being used to calculate <code>sum</code> has a
<em>binary</em> numeric representation, and our inputs are specified as <em>decimal</em>
numbers. Neither 0.1 nor 0.2 in decimal can be <a href="https://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/">represented exactly</a> in binary
and so they have been rounded to the nearest values which can be. The addition
is performed using binary arithmetic and finally is converted back into a
decimal representation to be printed.</p>
<p>We can see how these values have been rounded by printing them with a high
enough precision:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;0.1 -&gt; {:.55}&quot;, 0.1);
println!(&quot;0.2 -&gt; {:.55}&quot;, 0.2);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">0.1 -&gt; 0.1000000000000000055511151231257827021181583404541015625
0.2 -&gt; 0.2000000000000000111022302462515654042363166809082031250
</code></pre>
<h2 id="close-so-very-close"><a class="header" href="#close-so-very-close">Close, so very close</a></h2>
<p>Very few decimal numbers may be exactly represented in binary. Only powers of
two:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;4.0   -&gt; {:.55}&quot;, 4.0);
println!(&quot;2.0   -&gt; {:.55}&quot;, 2.0);
println!(&quot;1.0   -&gt; {:.55}&quot;, 1.0);
println!(&quot;0.5   -&gt; {:.55}&quot;, 0.5);
println!(&quot;0.25  -&gt; {:.55}&quot;, 0.25);
println!(&quot;0.125 -&gt; {:.55}&quot;, 0.125);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">4.0   -&gt; 4.0000000000000000000000000000000000000000000000000000000
2.0   -&gt; 2.0000000000000000000000000000000000000000000000000000000
1.0   -&gt; 1.0000000000000000000000000000000000000000000000000000000
0.5   -&gt; 0.5000000000000000000000000000000000000000000000000000000
0.25  -&gt; 0.2500000000000000000000000000000000000000000000000000000
0.125 -&gt; 0.1250000000000000000000000000000000000000000000000000000
</code></pre>
<p>And sums of powers of two:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{:.55}&quot;, 0.5 + 0.25);
println!(&quot;{:.55}&quot;, 4.0 + 0.5 + 0.125);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">0.7500000000000000000000000000000000000000000000000000000
4.6250000000000000000000000000000000000000000000000000000
</code></pre>
<p>Where:</p>
<ul>
<li>4.000 = 2<sup>2</sup></li>
<li>2.000 = 2<sup>1</sup></li>
<li>1.000 = 2<sup>0</sup></li>
<li>0.500 = 2<sup>-1</sup></li>
<li>0.250 = 2<sup>-2</sup></li>
<li>0.125 = 2<sup>-3</sup></li>
</ul>
<p>Most decimal numbers are not sums of powers of two<sup class="footnote-reference"><a href="#decimals">1</a></sup>, so every time we
convert a decimal into floating point there is a high chance that it will be
rounded. The difference between the input value and the converted <code>f64</code> floating
point value is known as the initial <a href="https://en.wikipedia.org/wiki/Round-off_error">roundoff error</a>.</p>
<h2 id="accumulating-errors"><a class="header" href="#accumulating-errors">Accumulating errors</a></h2>
<p>Conversion from decimal to binary is not the only source of error in floating
point arithmetic. If the only problem was the initial roundoff error, then we
could reasonably expect the sum 0.1 + 0.2 to be computed exactly and be equal
to the converted constant 0.3 when we test it with <code>==</code>.</p>
<p>It is not:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum = 0.1 + 0.2;

println!(&quot;sum -&gt; {:.55}&quot;, sum);
println!(&quot;0.3 -&gt; {:.55}&quot;, 0.3);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">sum -&gt; 0.3000000000000000444089209850062616169452667236328125000
0.3 -&gt; 0.2999999999999999888977697537484345957636833190917968750
</code></pre>
<p>Why aren't they the same? Well, <code>sum</code> has been rounded <em>up</em> to the nearest
representable <code>f64</code> number, and 0.3 has been rounded <em>down</em>.</p>
<p>Let's think a bit more about the original inputs. They have both been rounded
<em>up</em> compared to their decimal values:</p>
<pre><code class="language-txt">0.1 -&gt; 0.1000000000000000055511151231257827021181583404541015625
0.2 -&gt; 0.2000000000000000111022302462515654042363166809082031250
</code></pre>
<p>If we add these rounded values together by hand, we get a number that is just
slightly above 0.3:</p>
<pre><code class="language-txt">  0.1000000000000000055511151231257827021181583404541015625
+ 0.2000000000000000111022302462515654042363166809082031250
= 0.3000000000000000166533453693773481063544750213623046775
</code></pre>
<p>The results of operations on floating point values are rounded to the nearest
representable value<sup class="footnote-reference"><a href="#default">2</a></sup>. It just so happens that in this example, the <code>sum</code> of the
two rounded values is high enough to be rounded up, whereas 0.3 is low enough to
be rounded down. This is why checking they are equal with <code>==</code> returns false.</p>
<p>Nearly every operation on floating point numbers can result in further rounding,
amplifying the effect of previous rounding. You may be able to mitigate this
somewhat by reordering operations to reduce the magnitude, but it is impossible
to avoid error entirely.</p>
<h2 id="distant-relatives"><a class="header" href="#distant-relatives">Distant relatives</a></h2>
<p>Wait a minute though. If our two input two values are exactly representable as
binary numbers then why was the result of adding them together rounded at all?
Shouldn't <code>sum</code> be the same as the answer we calculated by hand? It is somewhat
higher than we expected:</p>
<pre><code class="language-txt">by hand: 0.3000000000000000166533453693773481063544750213623046775
by f64:  0.3000000000000000444089209850062616169452667236328125000
</code></pre>
<p>They are different because of the fundamental design of floating point numbers.
The big advantage of floating point types, and the reason that we may be happy
to deal with the small errors inherent in using them, is that they can represent
a literally <em>astronomically</em> larger range of absolute values than integer types
can in the same number of bits.</p>
<p>The trade off is that the granularity of floating point numbers changes with
their magnitude. As floating point numbers get larger the <em>absolute</em> distance
between adjacent values grows, and as they get smaller it shrinks, whereas the
<em>relative</em> distance between values remains constant. This is in contrast to integer
types where, regardless of magnitude, adjacent values are always the same
<em>absolute</em> distance away from each another (one), but their <em>relative</em> distance
changes.</p>
<p>Let's make this more concrete by comparing <code>i32</code> and <code>f32</code>. Each can represent
4,294,967,296 different values using their 32 bits, but they make very different
choices as to what those values are.</p>
<p>The positive range of <code>i32</code> can represent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0
1
...
2147483646
2147483647 // i32::MAX
<span class="boring">}
</span></code></pre></pre>
<p>The positive range of <code>f32</code> can represent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0.0
...
0.000000000000000000000000000000000000011754944 // f32::MIN_POSITIVE
0.000000000000000000000000000000000000011754945
...
340282330000000000000000000000000000000.0
340282350000000000000000000000000000000.0 // f32::MAX
∞ // f32::INFINITY                                        
<span class="boring">}
</span></code></pre></pre>
<p>As mentioned above, the <em>absolute</em> distance between every adjacent pair of <code>i32</code>
numbers within its range is always one, but their <em>relative</em> distance changes
depending on their magnitude:</p>
<pre><code class="language-txt">0 -&gt; 1:
absolute: 1 - 0 = 1
relative: 1 / 0 = ∞

1 -&gt; 2:
absolute: 2 - 1 = 1
relative: 2 / 1 = 2

...

2147483646 -&gt; 2147483647:
absolute: 2147483647 - 2147483646 = 1
relative: 2147483647 / 2147483646 = 1.0000000004656612873077392578125
</code></pre>
<p>The <code>f32</code> number line is a bit more complex. Zero and infinity are special
values at the extremes and the tiny range of subnormal values just above zero
act differently but the vast majority of <code>f32</code> values are <a href="https://en.wikipedia.org/wiki/Normal_number_(computing)">normal floating point
numbers</a> in the range from <code>f32::MIN_POSITIVE</code> to <code>f32::MAX</code>.</p>
<p>The absolute distance between each pair of adjacent normal <code>f32</code> values varies
depending on their size but their relative distance is always very close to
1.0000001. We can illustrate this with some help from the <a href="https://crates.io/crates/ieee754">ieee754</a> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ieee754::Ieee754;

let a = f32::MIN_POSITIVE;
let b = a.next();
println!(&quot;{} -&gt;\n{}:&quot;, a, b);
println!(&quot;absolute: {}&quot;, b - a);
println!(&quot;relative: {}\n&quot;, b / a);

let c = f32::MIN_POSITIVE.next();
let d = c.next();
println!(&quot;{} -&gt;\n{}:&quot;, c, d);
println!(&quot;absolute: {}&quot;, d - c);
println!(&quot;relative: {}\n&quot;, d / c);

println!(&quot;...\n&quot;);

let e = f32::MAX.prev();
let f = f32::MAX;
println!(&quot;{} -&gt;\n{}:&quot;, e, f);
println!(&quot;absolute: {}&quot;, f - e);
println!(&quot;relative: {}&quot;, f / e);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">0.000000000000000000000000000000000000011754944 -&gt;
0.000000000000000000000000000000000000011754945:
absolute: 0.000000000000000000000000000000000000000000001
relative: 1.0000001

0.000000000000000000000000000000000000011754945 -&gt;
0.000000000000000000000000000000000000011754946:
absolute: 0.000000000000000000000000000000000000000000001
relative: 1.0000001

...

340282330000000000000000000000000000000 -&gt;
340282350000000000000000000000000000000:
absolute: 20282410000000000000000000000000
relative: 1.0000001
</code></pre>
<h3 id="machine-epsilon"><a class="header" href="#machine-epsilon">Machine epsilon</a></h3>
<p>The absolute distance between adjacent numbers for a floating point type is
determined by multiples of that type's <em>machine epsilon</em>. This is the distance
between adjacent values in the range 1.0 to 2.0. For <code>f64</code> this is the constant
<code>f64::EPSILON</code>. We can scale it for every other range of powers of two to
determine the absolute distance between numbers in those ranges:</p>
<ul>
<li>0.25 to 0.5 contains 8,388,608 values, all a distance of <code>0.25 * f64::EPSILON</code> apart.</li>
<li>0.5  to 1.0 contains 8,388,608 values, all a distance of <code>0.5 * f64::EPSILON</code> apart.</li>
<li>1.0  to 2.0 contains 8,388,608 values, all a distance of <code>f64::EPSILON</code> apart.</li>
<li>2.0  to 4.0 contains 8,388,608 values, all a distance of <code>2.0 * f64::EPSILON</code> apart.</li>
<li>4.0  to 8.0 contains 8,388,608 values, all a distance of <code>4.0 * f64::EPSILON</code> apart.</li>
</ul>
<p>This is why our addition was unexpectedly rounded up:</p>
<ul>
<li><code>0.1</code> is in the range 0.0625 to 0.125, which are all <code>0.0625 * f64::EPSILON</code> apart.</li>
<li><code>0.2</code> is in the range 0.125 to 0.25, which are all <code>0.125 * f64::EPSILON</code> apart.</li>
<li><code>0.1 + 0.2</code> is in the range 0.25 to 0.5, which are all <code>0.25 * f64::EPSILON</code> apart.</li>
</ul>
<p>The input values 0.1 and 0.2 were both rounded up to the nearest values in their
respective ranges. The result of adding them together is within a range with
a lower granularity and was not exactly representable, so it needed to be
rounded to the nearest value that is.</p>
<h2 id="it-gets-much-worse"><a class="header" href="#it-gets-much-worse">It gets much worse</a></h2>
<p>But that's not the end of the story.</p>
<p>There are far more significant sources of error in most numerical calculations
than the roundoff errors we have described so far. If the inputs are real world
values, then there is almost certainly some <a href="https://en.wikipedia.org/wiki/Observational_error">measurement error</a> in how they were
collected. Algorithms like physics simulations that use discrete steps to
approximate continuous functions introduce <a href="https://en.wikipedia.org/wiki/Truncation_error">truncation error</a>. Even the
underyling mathematics may amplify existing error if it is <a href="https://nhigham.com/2020/08/04/what-is-numerical-stability/">numerically
unstable</a>, for example when dividing large numbers by much smaller ones or if
values undergo <a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">catastrophic cancellation</a>.</p>
<p>I'll say that again, because it's so important: in most real world programs,
floating point roundoff error is so small as to be insignificant compared to
other sources of error. Floating point numerics may be inappropriate for values
that have strict absolute precision requirements, such as currency, but in
general there is no need to shy away from using them because of their rounding
behaviour.</p>
<p>Every numerical algorithm is unique and there is no one size fits all solution
or set of defaults to account for the error inherent in them and hide it away.
In fact, there is an entire field of active mathematical research concerned with
computational error, <a href="https://en.wikipedia.org/wiki/Numerical_analysis">Numerical Analysis</a>. What we can do, however, is learn to
reason about these sources of error and provide tools for taking it into account
and communicating our thoughts to future readers and maintainers.</p>
<h2 id="close-enough"><a class="header" href="#close-enough">Close enough</a></h2>
<p>Bearing that in mind, let's return to our original comparison. Now that we know
why the exact <code>==</code> comparison failed, we can instead check that the difference
between the expected and actual values lies within a margin of error, known as
the tolerance. This is what the <a href="tutorials/../../doc/float_eq/macro.float_eq.html"><code>float_eq!</code></a> macro is for.</p>
<h3 id="absolute-tolerance-comparison"><a class="header" href="#absolute-tolerance-comparison">Absolute tolerance comparison</a></h3>
<p>The simplest algorithm to check if two floating point numbers are equal is an
<a href="tutorials/../background/float_comparison_algorithms.html#absolute-tolerance-comparison">absolute tolerance comparison</a>. This tests that the absolute difference between
two values lies within a specified tolerance and is invoked with the syntax
<code>abs &lt;= tol</code>. We have calculated that in our very simple example the values may
differ by at most <code>0.25 * f64::EPSILON</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use float_eq::float_eq;

let sum = 0.1 + 0.2;

if float_eq!(sum, 0.3, abs &lt;= 0.25 * f64::EPSILON) {
    println!(&quot;Floating point math is working as expected!&quot;);
} else {
    println!(&quot;Something has gone horribly wrong!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">Floating point math is working as expected!
</code></pre>
<h3 id="relative-tolerance-comparison"><a class="header" href="#relative-tolerance-comparison">Relative tolerance comparison</a></h3>
<p>Hurray! However, manually scaling the tolerance to the range of the operands is
not very elegant. Fortunately, given that we know that we are comparing two
normal numbers, we can use a <a href="tutorials/../background/float_comparison_algorithms.html#relative-tolerance-comparison">relative tolerance comparison</a> to scale the
tolerance for us. The second operand is our expected value, so we may choose to
use <code>r2nd &lt;= tol</code>. With a relative tolerance comparison, the tolerance should be
specified as if we were testing a value in the range 1.0 to 2.0, so
<code>f64::EPSILON</code> indicates we are expecting our operands to be no more than one
representable value apart from each other<sup class="footnote-reference"><a href="#relative">3</a></sup>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use float_eq::float_eq;
</span><span class="boring">let sum = 0.1 + 0.2;
</span>if float_eq!(sum, 0.3, r2nd &lt;= f64::EPSILON) {
    println!(&quot;Floating point math is working as expected!&quot;);
} else {
    println!(&quot;Something has gone horribly wrong!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">Floating point math is working as expected!
</code></pre>
<h3 id="ulps-based-comparison"><a class="header" href="#ulps-based-comparison">ULPs based comparison</a></h3>
<p>If both numbers are normal <em>and</em> the same sign, which is often the case, we can
use an <a href="tutorials/../background/float_comparison_algorithms.html#units-in-the-last-place-ulps-comparison">ULPs comparison</a>, another form of relative check. This uses a property
of the <a href="https://randomascii.wordpress.com/2012/01/23/stupid-float-tricks-2/">underlying representation</a> of floating point numbers which means that
when we interpret their bits as unsigned integers, the adjacent floats are the
adjacent integer values above and below. By using <code>ulps &lt;= tol</code> to invoke one of
these checks, the tolerance is the maximum number of representable values apart
they may be regardless of their magnitude. In our example, we know they may be
at most one representable <code>f64</code> value apart:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use float_eq::float_eq;
</span><span class="boring">let sum = 0.1 + 0.2;
</span>if float_eq!(sum, 0.3, ulps &lt;= 1) {
    println!(&quot;Floating point math is working as expected!&quot;);
} else {
    println!(&quot;Something has gone horribly wrong!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">Floating point math is working as expected!
</code></pre>
<h2 id="asserting-ourselves"><a class="header" href="#asserting-ourselves">Asserting ourselves</a></h2>
<p>The <code>float_eq</code> library also includes <a href="tutorials/../../doc/float_eq/macro.assert_float_eq.html"><code>assert_float_eq!</code></a> to accompany the
boolean <a href="tutorials/../../doc/float_eq/macro.float_eq.html"><code>float_eq!</code></a> operator. To illustrate their use and show some more
advanced comparison techniques, we will define a very simple numerical
integrator. This function takes an initial value and step size, then advances
the value by an arbitrary number of steps:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn integrate(initial: f64, step: f64, count: usize) -&gt; f64 {
    let mut sum = initial;
    for _ in 0..count {
        sum += step;
    }
    sum
}
<span class="boring">}
</span></code></pre></pre>
<p>Say we want to unit test a number of different sets of input to this algorithm,
we might build ourselves a wrapper for it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_integrate(initial: f64, step: f64, count: usize, expected: f64) {
    let actual = integrate(initial, step, count);
    assert_float_eq!(actual, expected, r2nd &lt;= f64::EPSILON);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the syntax for assert, <code>r2nd &lt;= tol</code> is the same as for the boolean
form, and that you may use any of the same algorithms if you wish. Arbitrarily,
we have begun with the same tolerance as for our first example comparison. This
means that the equivalent of our first simple comparison will pass this test
just fine:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test_integrate(0.2, 0.1, 1, 0.3);
<span class="boring">}
</span></code></pre></pre>
<h3 id="drifting-away"><a class="header" href="#drifting-away">Drifting away</a></h3>
<p>Let's add some tests which use an increasing step size. Our first two are within
the existing expected tolerance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test_integrate(0.0, 0.1, 1, 0.1);
test_integrate(0.0, 0.1, 10, 1.0);
<span class="boring">}
</span></code></pre></pre>
<p>But when we look at 100 steps, we find that our test fails:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test_integrate(0.0, 0.1, 100, 10.0);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">thread 'main' panicked at 'assertion failed: `float_eq!(left, right, r2nd &lt;= t)`
        left: `9.99999999999998`,
       right: `10.0`,
    abs_diff: `0.000000000000019539925233402755`,
   ulps_diff: `Some(11)`,
    [r2nd] t: `0.000000000000002220446049250313`', src\main.rs:15:9
</code></pre>
<p>This assert form prints out the values of the operands, like the standard Rust
asserts, but it also provides additional context information to help us make
sense of why it failed. Here, t is the tolerance:</p>
<ul>
<li><code>abs_diff</code> is the absolute difference between the two values: 
<code>(left - right).abs()</code>.</li>
<li><code>ulps_diff</code> is the difference in ULPs between the two values, the count of
representable values they are apart. It may be <code>None</code> if two numbers have
different signs.</li>
<li><code>[r2nd] t</code> is the tolerance as scaled to the range of <code>right</code> (the second
operand).</li>
</ul>
<p>We can see that our actual and expected values are eleven ULPs from one another.
That means that our tolerance of <code>f64::EPSILON</code>, equivalent to one ULP, is
inadequate. This is because we are performing <code>count</code> number of additions, and
each one of those provides an answer accurate to within 0.5 ULPs, so they have
accumulated more error than a single step or ten steps would. We might reason
that our tolerance should therefore be some function of the number of steps,
perhaps <code>(count * 0.5) * f64::EPSILON</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_integrate(initial: f64, step: f64, count: usize, expected: f64) {
    let actual = integrate(initial, step, count);
    assert_float_eq!(
        actual,
        expected,
        r2nd &lt;= ((count as f64) * 0.5) * f64::EPSILON
    );
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="absolute-zero"><a class="header" href="#absolute-zero">Absolute zero</a></h3>
<p>Let's take a look at another failure case, when we count backwards to zero:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test_integrate(10.0, -0.1, 100, 0.0);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">thread 'main' panicked at 'assertion failed: `float_eq!(left, right, r2nd &lt;= t)`
        left: `0.000000000000018790524691780774`,
       right: `0.0`,
    abs_diff: `0.000000000000018790524691780774`,
   ulps_diff: `Some(4401468191289638912)`,
    [r2nd] t: `0.0`', src\main.rs:15:9
</code></pre>
<p>Wow! There are a couple of things to note about this failure. The first is that
because we are comparing versus zero, scaling our tolerance doesn't work - zero
times anything is zero, so the tolerance does not take into account the step
count. Even more noticable though is just <em>how far away</em> our actual value is in
terms of representable numbers.</p>
<p>There are two reasons why this has happened. The first is that, as mentioned
above, zero is a special number and does not have the same properties as normal
floating point numbers. The second is that our final subtraction leaves us with
a result many orders of magnitude smaller than the previous sum total, resulting
in a <a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">catastrophic cancellation</a>.</p>
<p>The solution here is to use a more sophisticated calculation for our tolerance,
one that takes into account the nature of the calculation itself. It needs to be
an absolute test, since we may be comparing versus zero. It should also scale
relative to the largest intermediate value in the calculation and take into
account the potential rounding errors from our repeated addition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test_integrate(initial: f64, step: f64, count: usize, expected: f64) {
    let actual = integrate(initial, step, count);
    let half_count = (count as f64) * 0.5;
    let tol = f64::EPSILON * half_count * f64::max(initial.abs(), actual.abs());
    assert_float_eq!(actual, expected, abs &lt;= tol);
}
<span class="boring">}
</span></code></pre></pre>
<p>This further illustates that there is no one right or general way to express the
tolerances of numeric algorithms. Every comparison will be based on the specific
calculation being performed and frequently the particular inputs.</p>
<h3 id="custom-messages"><a class="header" href="#custom-messages">Custom messages</a></h3>
<p>The assert macros may include a custom message in the same manner as the
standard Rust asserts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_float_eq!(
    actual,
    expected,
    r2nd &lt;= f64::EPSILON,
    &quot;\nWhere: initial: {}, step: {}, count: {}&quot;,
    initial,
    step,
    count
);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-txt">thread 'main' panicked at 'assertion failed: `float_eq!(left, right, r2nd &lt;= t)`
        left: `9.99999999999998`,
       right: `10.0`,
    abs_diff: `0.000000000000019539925233402755`,
   ulps_diff: `Some(11)`,
    [r2nd] t: `0.000000000000002220446049250313`:
Where: initial: 0, step: 0.1, count: 100', src\main.rs:14:9
</code></pre>
<h2 id="staying-afloat"><a class="header" href="#staying-afloat">Staying afloat</a></h2>
<p>Hopefully that's given you some flavour of the issues that crop up when
implementing numerical methods and how <code>float_eq</code> may aid you when they do. At
this point you may be interested in learning how to perform some <a href="tutorials/../how_to.html">specific
tasks</a>, reading some more general <a href="tutorials/../background.html">background</a> explanations or browsing the <a href="tutorials/../api_documentation.html">API
documentation</a>.</p>
<hr />
<div class="footnote-definition" id="decimals"><sup class="footnote-definition-label">1</sup>
<p>They are in fact all exact sums of multiples of powers of ten.</p>
</div>
<div class="footnote-definition" id="default"><sup class="footnote-definition-label">2</sup>
<p>By default. Other rounding modes such as always rounding up, down or
toward zero are available.</p>
</div>
<div class="footnote-definition" id="relative"><sup class="footnote-definition-label">3</sup>
<p>In general, <code>n * fXX::EPSILON</code> as a relative tolerance means &quot;at
most n representable values apart&quot;, for example you might use a tolerance of
<code>4.0 * f64::EPSILON</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to"><a class="header" href="#how-to">How to</a></h1>
<ul>
<li><a href="./how_to/compare_floating_point_numbers.html">Compare floating point numbers</a></li>
<li><a href="./how_to/compare_composite_types.html">Compare composite types</a></li>
<li><a href="./how_to/interpret_assert_failure_messages.html">Interpret assert failure messages</a></li>
<li><a href="./how_to/compare_custom_types.html">Compare custom types</a></li>
<li><a href="./how_to/derive_the_traits.html">Derive the traits</a></li>
<li><a href="./how_to/manually_implement_the_traits.html">Manually implement the traits</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-compare-floating-point-numbers"><a class="header" href="#how-to-compare-floating-point-numbers">How to compare floating point numbers</a></h1>
<ol>
<li>
<p>Determine which <a href="how_to/../background/float_comparison_algorithms.html">comparison algorithm</a> best suits your purposes.</p>
</li>
<li>
<p>Determine the tolerance required based on the sources of the error in how the
numbers were entered/calculated. </p>
</li>
<li>
<p>If you need a boolean result, then use <a href="how_to/../../doc/float_eq/macro.float_eq.html"><code>float_eq!</code></a> or <a href="how_to/../../doc/float_eq/macro.float_ne.html"><code>float_ne!</code></a>. The
two numbers should be the first and second operands, and then the tolerance is
the value after the <code>&lt;=</code>. For example, to compare two <code>f32</code> numbers stored in
<code>a</code> and <code>b</code> using a relative tolerance of <code>tol</code> scaled to the magnitude of the
second operand:</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>float_eq!(a, b, r2nd &lt;= tol)
<span class="boring">}
</span></code></pre></pre>
<ol start="4">
<li>If instead you wish to assert that the two numbers are equal and panic if
they are not, you can use <a href="how_to/../../doc/float_eq/macro.assert_float_eq.html"><code>assert_float_eq!</code></a> or <a href="how_to/../../doc/float_eq/macro.assert_float_ne.html"><code>assert_float_ne!</code></a>. The
syntax is the same, and may optionally include formatted text after the
comparisons as with standard Rust asserts:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_float_eq!(a, b, r2nd &lt;= tol);
assert_float_eq!(a, b, r2nd &lt;= tol, &quot;Example context: {}&quot;, context);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-compare-composite-types"><a class="header" href="#how-to-compare-composite-types">How to compare composite types</a></h1>
<ol>
<li>Composite types such as arrays, tuples and structs may be compared by
specifying a per-field tolerance in an instance of the same type:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1.0, -2.0, 3.0];
let b = [-1.0, 2.0, 3.5];
assert_float_eq!(a, b, abs &lt;= [2.0, 4.0, 0.5]);

let c = Complex32 { re: 2.0, im: 4.000_002 };
let d = Complex32 { re: 2.000_000_5, im: 4.0 };
assert_float_eq!(c, d, rmax &lt;= Complex32 { re: 0.000_000_25, im: 0.000_000_5 });
assert_float_eq!(c, d, ulps &lt;= ComplexUlps32 { re: 2, im: 4 });
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>Homogeneous types may also support the <code>_all</code> variants of the checks, which
allow you to specify a single tolerance to use across all fields:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_float_eq!(a, b, abs_all &lt;= 4.0);

assert_float_eq!(c, d, rmax_all &lt;= 0.000_000_5);
assert_float_eq!(c, d, ulps_all &lt;= 4);
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>Checks may be extended over new types by implementing the <a href="how_to/./compare_custom_types.html">extension traits</a>.</li>
</ol>
<p><em>Note that to compare num::Complex32 you will need to enable the &quot;num&quot; feature
for float_eq.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-interpret-assert-failure-messages"><a class="header" href="#how-to-interpret-assert-failure-messages">How to interpret assert failure messages</a></h1>
<p>Assertion failure messages provide context information that hopefully helps
in determining how a check failed. For example, this line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_float_eq!(4.0f32, 4.000_008, rmax &lt;= 0.000_001);
<span class="boring">}
</span></code></pre></pre>
<p>Panics with this error message:</p>
<pre><code class="language-text">thread 'main' panicked at 'assertion failed: `float_eq!(left, right, rmax &lt;= t)`
        left: `4.0`,
       right: `4.000008`,
    abs_diff: `0.000008106232`,
   ulps_diff: `Some(17)`,
    [rmax] t: `0.000004000008`', assert_failure.rs:15:5
</code></pre>
<p>Where:</p>
<ul>
<li><strong>rmax &lt;= t</strong> - indicates the type of comparison which was carried out.</li>
<li><strong>left</strong> - the value of the first operand.</li>
<li><strong>right</strong> - the value of the second operand.</li>
<li><strong>abs_diff</strong> - the absolute difference between <code>left</code> and <code>right</code>.</li>
<li><strong>ulps_diff</strong> - the difference between <code>left</code> and <code>right</code> in ULPs. If it is
None, that is because they have different signs or at least one is <code>NaN</code>.</li>
<li><strong>[rmax] t</strong> - the tolerance used in the comparison against the relevant
difference, here <code>abs_diff</code>, <em>after</em> it has been scaled relative to an operand,
in this case <code>max(left, right)</code> since it is <code>rmax</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-compare-custom-types"><a class="header" href="#how-to-compare-custom-types">How to compare custom types</a></h1>
<p>To extend <code>float_eq</code> functionality over a new type requires implenting the
relevant extension traits.</p>
<ol>
<li>
<p>If your type is a struct or tuple struct that consists of fields that already
implement the required traits, then you may use a derive macro. See <a href="how_to/./derive_the_traits.html">How to
derive the traits</a>.</p>
</li>
<li>
<p>If your type cannot have the traits derived for it, of if you do not wish to
enable the &quot;derive&quot; feature, see <a href="how_to/./manually_implement_the_traits.html">How to manually implement the traits</a>.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-derive-the-traits"><a class="header" href="#how-to-derive-the-traits">How to derive the traits</a></h1>
<p>This article will explain how to enable a new type for use with the <a href="how_to/../../doc/float_eq/macro.float_eq.html">float_eq!</a>,
<a href="how_to/../../doc/float_eq/macro.float_ne.html">float_ne!</a>, <a href="how_to/../../doc/float_eq/macro.assert_float_eq.html">assert_float_eq!</a> and <a href="how_to/../../doc/float_eq/macro.assert_float_ne.html">assert_float_ne!</a> macros. However, deriving
the necessary traits is currently only possible if this type is a struct or
tuple struct and is not generic. If not, or if you do not wish to enable the
derive feature, see <a href="how_to/./manually_implement_the_traits.html">How to manually implement the traits</a>.</p>
<h2 id="enabling-the-derive-feature"><a class="header" href="#enabling-the-derive-feature">Enabling the derive feature</a></h2>
<p>Enable the optional &quot;derive&quot; feature in your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies.float_eq]
version = &quot;1&quot;
features = [&quot;derive&quot;]
</code></pre>
<h2 id="deriving-the-required-traits"><a class="header" href="#deriving-the-required-traits">Deriving the required traits</a></h2>
<p>Add <a href="how_to/../../doc/float_eq/attr.derive_float_eq.html"><code>#[derive_float_eq]</code></a> to the
new type. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive_float_eq(
    ulps_tol = &quot;PointUlps&quot;, 
    ulps_tol_derive = &quot;Clone, Copy, Debug, PartialEq&quot;,
    debug_ulps_diff = &quot;PointDebugUlpsDiff&quot;,
    debug_ulps_diff_derive = &quot;Clone, Copy, Debug, PartialEq&quot;
)]
#[derive(Debug, PartialEq, Clone, Copy)]
struct Point {
    pub x: f64,
    pub y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>The parameters:</p>
<ul>
<li><code>ulps_tol</code>: required, will name a new type to provide per-field <a href="how_to/../background/float_comparison_algorithms.html#units-in-the-last-place-ulps-comparison">ULPs</a> tolerances.</li>
<li><code>ulps_tol_derive</code>: optional, provides a list of traits to derive on the <code>ulps_tol</code> type.</li>
<li><code>debug_ulps_diff</code>: required, will name a new type used to display per-field <a href="how_to/../background/float_comparison_algorithms.html#units-in-the-last-place-ulps-comparison">ULPs</a> differences.</li>
<li><code>debug_ulps_diff_derive</code>: optional, provides a list of traits to derive on the <code>debug_ulps_diff</code> type.</li>
</ul>
<p>This will implement two new types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct PointUlps {
    pub x: UlpsTol&lt;f64&gt;,
    pub y: UlpsTol&lt;f64&gt;,
}

#[derive(Debug, Clone, Copy, PartialEq)]
struct PointDebugUlpsDiff {
    pub x: DebugUlpsDiff&lt;f64&gt;,
    pub y: DebugUlpsDiff&lt;f64&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will also implement <a href="how_to/../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>, <a href="how_to/../../doc/float_eq/trait.FloatEq.html">FloatEq</a>, <a href="how_to/../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a> and
<a href="how_to/../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a> for your type. You may now compare it as a composite type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Point { x: 1.0, y: -2.0 };
let b = Point { x: 1.1, y: -2.2 };
let c = Point { x: 1.000_000_000_000_000_9, y: -2.000_000_000_000_001_3 };
let eps = f64::EPSILON;

assert_float_eq!(a, b, abs &lt;= Point { x: 0.15, y: 0.25 });
assert_float_eq!(a, c, rmax &lt;= Point { x: 4.0 * eps, y: 5.0 * eps });
assert_float_eq!(a, c, ulps &lt;= PointUlps { x: 4, y: 3 });
<span class="boring">}
</span></code></pre></pre>
<h2 id="enabling-the-_all-variants-of-checks"><a class="header" href="#enabling-the-_all-variants-of-checks">Enabling the <code>_all</code> variants of checks</a></h2>
<p>If your type is homogeneous, that is if it consists of fields that are all the
same underlying floating point type, then you may provide the optional <code>all_tol</code>
parameter to <code>#[derive_float_eq]</code> with that underlying type (usually <code>f32</code> or
<code>f64</code>). This will enable the <code>_all</code> variants of checks for it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive_float_eq(
    ulps_tol = &quot;PointUlps&quot;, 
    ulps_tol_derive = &quot;Clone, Copy, Debug, PartialEq&quot;,
    debug_ulps_diff = &quot;PointDebugUlpsDiff&quot;,
    debug_ulps_diflf_derive = &quot;Clone, Copy, Debug, PartialEq&quot;,
    all_tol = &quot;f64&quot;
)]
#[derive(Debug, PartialEq, Clone, Copy)]
struct Point {
    pub x: f64,
    pub y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will additionally implement the <a href="how_to/../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a> and <a href="how_to/../../doc/float_eq/trait.AssertFloatEqAll.html">AssertFloatEqAll</a> for
your type. You may now compare it using the <code>_all</code> check variants:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Point { x: 1.0, y: -2.0 };
let b = Point { x: 1.1, y: -2.2 };
let c = Point { x: 1.000_000_000_000_000_9, y: -2.000_000_000_000_001_3 };
let eps = f64::EPSILON;

assert_float_eq!(a, b, abs_all &lt;= 0.25);
assert_float_eq!(a, c, rmax_all &lt;= 5.0 * eps);
assert_float_eq!(a, c, ulps_all &lt;= 4);
<span class="boring">}
</span></code></pre></pre>
<h2 id="deriving-individual-traits"><a class="header" href="#deriving-individual-traits">Deriving individual traits</a></h2>
<p>The <code>#[derive_float_eq]</code> macro is recommended but if required you may implement
the traits by individually deriving them. The <code>#[float_eq]</code> attribute should be
used to pass through the relevant parameters. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(
    Debug, PartialEq, Clone, Copy, FloatEqUlpsTol, FloatEq,
    FloatEqDebugUlpsDiff, AssertFloatEq
)]
#[float_eq(
    ulps_tol = &quot;PointUlps&quot;, 
    ulps_tol_derive = &quot;Clone, Copy, Debug, PartialEq&quot;,
    debug_ulps_diff = &quot;PointDebugUlpsDiff&quot;,
    debug_ulps_diff_derive = &quot;Clone, Copy, Debug, PartialEq&quot;
)]
struct Point {
    pub x: f64,
    pub y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="how_to/../../doc/float_eq/macro.float_eq.html">float_eq!</a> and <a href="how_to/../../doc/float_eq/macro.float_ne.html">float_ne!</a> macros require <a href="how_to/../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a> and <a href="how_to/../../doc/float_eq/trait.FloatEq.html">FloatEq</a>
and may optionally use <a href="how_to/../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a>. Likewise, <a href="how_to/../../doc/float_eq/macro.assert_float_eq.html">assert_float_eq!</a> and 
<a href="how_to/../../doc/float_eq/macro.assert_float_ne.html">assert_float_ne!</a> require <a href="how_to/../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a> and <a href="how_to/../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a> and may
optionally use <a href="how_to/../../doc/float_eq/trait.AssertFloatEqAll.html">AssertFloatEqAll</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Trait</th><th>Requires</th><th>Parameters</th></tr></thead><tbody>
<tr><td><a href="how_to/../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a></td><td></td><td><code>ulps_tol</code>, <code>ulps_tol_derive</code></td></tr>
<tr><td><a href="how_to/../../doc/float_eq/trait.FloatEq.html">FloatEq</a></td><td>FloatEqUlpsTol</td><td></td></tr>
<tr><td><a href="how_to/../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a></td><td>FloatEq</td><td><code>all_tol</code></td></tr>
<tr><td><a href="how_to/../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a></td><td></td><td><code>debug_ulps_diff</code>, <code>debug_ulps_diff_derive</code></td></tr>
<tr><td><a href="how_to/../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a></td><td>FloatEq, FloatEqDebugUlpsDiff</td><td></td></tr>
<tr><td><a href="how_to/../../doc/float_eq/trait.AssertFloatEqAll.html">AssertFloatEqAll</a></td><td>AssertFloatEq, FloatEqAll</td><td><code>all_tol</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-manually-implement-the-traits"><a class="header" href="#how-to-manually-implement-the-traits">How to manually implement the traits</a></h1>
<p>This article will explain how to enable a new type for use with the <a href="how_to/../../doc/float_eq/macro.float_eq.html">float_eq!</a>,
<a href="how_to/../../doc/float_eq/macro.float_ne.html">float_ne!</a>, <a href="how_to/../../doc/float_eq/macro.assert_float_eq.html">assert_float_eq!</a> and <a href="how_to/../../doc/float_eq/macro.assert_float_ne.html">assert_float_ne!</a> macros. If your type is
a struct or tuple struct and is not generic, then you may wish to derive these
traits instead, see <a href="how_to/./derive_the_traits.html">How to derive the traits</a>.</p>
<p>The <a href="how_to/../../doc/float_eq/macro.float_eq.html">float_eq!</a> and <a href="how_to/../../doc/float_eq/macro.float_ne.html">float_ne!</a> macros require <a href="how_to/../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a> and <a href="how_to/../../doc/float_eq/trait.FloatEq.html">FloatEq</a>
and may optionally use <a href="how_to/../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a>. Likewise, <a href="how_to/../../doc/float_eq/macro.assert_float_eq.html">assert_float_eq!</a> and 
<a href="how_to/../../doc/float_eq/macro.assert_float_ne.html">assert_float_ne!</a> require <a href="how_to/../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a> and <a href="how_to/../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a> and may
optionally use <a href="how_to/../../doc/float_eq/trait.AssertFloatEqAll.html">AssertFloatEqAll</a>.</p>
<h2 id="the-point-type"><a class="header" href="#the-point-type">The Point type</a></h2>
<p>By way of example, we will implement the traits for this Point type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct Point {
    pub x: f64,
    pub y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="implementing-floatequlpstol"><a class="header" href="#implementing-floatequlpstol">Implementing FloatEqUlpsTol</a></h2>
<p>Provide an <a href="how_to/../../doc/float_eq/type.UlpsTol.html">UlpsTol</a> representation for each of the fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct PointUlps {
    pub x: UlpsTol&lt;f64&gt;,
    pub y: UlpsTol&lt;f64&gt;,
}

impl FloatEqUlpsTol for Point {
    type UlpsTol = PointUlps;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementing-floateq"><a class="header" href="#implementing-floateq">Implementing FloatEq</a></h3>
<p>Requires <a href="how_to/../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>. Implementation is usually a matter of calling through
to an underlying <a href="how_to/../../doc/float_eq/trait.FloatEq.html">FloatEq</a> method for each field in turn. If not, you will need
to take a close look at the descriptions of the algorithms on a method by method
basis:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FloatEq for Point {
    type Tol = Point;

    fn eq_abs(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_abs(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_abs(&amp;other.y, &amp;tol.y)
    }

    fn eq_rmax(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_rmax(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_rmax(&amp;other.y, &amp;tol.y)
    }

    fn eq_rmin(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_rmin(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_rmin(&amp;other.y, &amp;tol.y)
    }

    fn eq_r1st(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_r1st(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_r1st(&amp;other.y, &amp;tol.y)
    }

    fn eq_r2nd(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_r2nd(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_r2nd(&amp;other.y, &amp;tol.y)
    }

    fn eq_ulps(&amp;self, other: &amp;Self, tol: &amp;UlpsTol&lt;Point&gt;) -&gt; bool {
        self.x.eq_ulps(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_ulps(&amp;other.y, &amp;tol.y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementing-floateqall"><a class="header" href="#implementing-floateqall">Implementing FloatEqAll</a></h3>
<p>Select a tolerance type to compare recursively with each field in your type,
likely <code>f32</code> or <code>f64</code>. Implementation is then usually a matter of calling
through to an underlying <a href="how_to/../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a> method for each field in turn. If not, you
will need to take a close look at the descriptions of the algorithms on a method
by method basis:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FloatEqAll for Point {
    type AllTol = f64;

    fn eq_abs_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_abs_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_abs_all(&amp;other.y, tol)
    }

    fn eq_rmax_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_rmax_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_rmax_all(&amp;other.y, tol)
    }

    fn eq_rmin_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_rmin_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_rmin_all(&amp;other.y, tol)
    }

    fn eq_r1st_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_r1st_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_r1st_all(&amp;other.y, tol)
    }

    fn eq_r2nd_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_r2nd_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_r2nd_all(&amp;other.y, tol)
    }

    fn eq_ulps_all(&amp;self, other: &amp;Self, tol: &amp;UlpsTol&lt;f64&gt;) -&gt; bool {
        self.x.eq_ulps_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_ulps_all(&amp;other.y, tol)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementing-floateqdebugulpsdiff"><a class="header" href="#implementing-floateqdebugulpsdiff">Implementing FloatEqDebugUlpsDiff</a></h3>
<p>Types should provide a <a href="how_to/../../doc/float_eq/type.DebugUlpsDiff.html">DebugUlpsDiff</a> representation for each of their fields:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct PointDebugUlpsDiff {
    pub x: DebugUlpsDiff&lt;f64&gt;,
    pub y: DebugUlpsDiff&lt;f64&gt;,
}

impl FloatEqDebugUlpsDiff for Point {
    type DebugUlpsDiff = PointDebugUlpsDiff;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementing-assertfloateq"><a class="header" href="#implementing-assertfloateq">Implementing AssertFloatEq</a></h3>
<p>Requires <a href="how_to/../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>, <a href="how_to/../../doc/float_eq/trait.FloatEq.html">FloatEq</a> and <a href="how_to/../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a>. Implementation
is then usually a matter of simply calling through to an underlying
<a href="how_to/../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a> method for each field in turn. If not, you will need to take a
close look at the descriptions of the algorithms on a method by method basis:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AssertFloatEq for Point {
    type DebugAbsDiff = Self;
    type DebugTol = Self;

    fn debug_abs_diff(&amp;self, other: &amp;Self) -&gt; Point {
        Point {
            x: self.x.debug_abs_diff(&amp;other.x),
            y: self.y.debug_abs_diff(&amp;other.y),
        }
    }

    fn debug_ulps_diff(&amp;self, other: &amp;Self) -&gt; PointDebugUlpsDiff {
        PointDebugUlpsDiff {
            x: self.x.debug_ulps_diff(&amp;other.x),
            y: self.y.debug_ulps_diff(&amp;other.y),
        }
    }

    fn debug_abs_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_abs_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_abs_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_rmax_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_rmax_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_rmax_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_rmin_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_rmin_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_rmin_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_r1st_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_r1st_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_r1st_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_r2nd_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_r2nd_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_r2nd_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_ulps_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;PointUlps,
    ) -&gt; PointUlps {
        PointUlps {
            x: self.x.debug_ulps_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_ulps_tol(&amp;other.y, &amp;tol.y),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementing-assertfloateqall"><a class="header" href="#implementing-assertfloateqall">Implementing AssertFloatEqAll</a></h3>
<p>Requires <a href="how_to/../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>, <a href="how_to/../../doc/float_eq/trait.FloatEq.html">FloatEq</a>, <a href="how_to/../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a>, <a href="how_to/../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a>
and <a href="how_to/../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a>. Implementation is then usually a matter of simply calling
through to an underlying <a href="how_to/../../doc/float_eq/trait.AssertFloatEqAll.html">AssertFloatEqAll</a> method for each field in turn. If
not, you will need to take a close look at the descriptions of the algorithms on
a method by method basis:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AssertFloatEqAll for Point {
    type AllDebugTol = Self;

    fn debug_abs_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_abs_all_tol(&amp;other.x, tol),
            y: self.y.debug_abs_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_rmax_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_rmax_all_tol(&amp;other.x, tol),
            y: self.y.debug_rmax_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_rmin_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_rmin_all_tol(&amp;other.x, tol),
            y: self.y.debug_rmin_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_r1st_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_r1st_all_tol(&amp;other.x, tol),
            y: self.y.debug_r1st_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_r2nd_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_r2nd_all_tol(&amp;other.x, tol),
            y: self.y.debug_r2nd_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_ulps_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;UlpsTol&lt;Self::AllTol&gt;,
    ) -&gt; UlpsTol&lt;Self::AllDebugTol&gt; {
        PointUlps {
            x: self.x.debug_ulps_all_tol(&amp;other.x, tol),
            y: self.y.debug_ulps_all_tol(&amp;other.y, tol),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<ul>
<li><a href="./background/float_comparison_algorithms.html">Float comparison algorithms</a></li>
<li><a href="./background/resources.html">Resources</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floating-point-comparison-algorithms"><a class="header" href="#floating-point-comparison-algorithms">Floating point comparison algorithms</a></h1>
<p>Descriptions of the underlying comparison algorithms used by <a href="http://crates.io/crates/float_eq">float_eq</a>.</p>
<h2 id="absolute-tolerance-comparison-1"><a class="header" href="#absolute-tolerance-comparison-1">Absolute tolerance comparison</a></h2>
<pre><code>abs &lt;= tol
</code></pre>
<p>A check to see how far apart two expressions are by comparing the absolute
difference between them to an absolute tolerance. Mathematically, this is:</p>
<pre><code>|a - b| &lt;= tol
</code></pre>
<p>Equivalent to, using <code>f32</code> as an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn float_eq_abs(a: f32, b: f32, tol: f32) -&gt; bool {
    // the PartialEq check covers equality of infinities
    a == b || (a - b).abs() &lt;= tol
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the simplest method of testing the equality of two floats and may be
sufficient if you know the absolute margin of error for your calculation given
the values being tested. However, absolute tolerance tests <em>do not</em> work well for
general comparison of floating point numbers, because they do not take into
account that normal values' granularity changes with their magnitude. Thus any
given choice of <code>tol</code> is likely to work for one specific exponent's range and
poorly outside of it.</p>
<p>In some circumstances absolute tolerance comparisons are required. If you wish
to compare against zero, an infinity, or subnormal values then the assumptions
that relative tolerance or ULPs based checks make about how neighbouring values
are related to one another break down. Similarly, if the underlying mathematics
of your algorithm is <a href="https://nhigham.com/2020/08/04/what-is-numerical-stability/">numerically unstable</a>, for example if it is prone to
<a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">catastrophic cancellation</a>, then you may find that you need to reach for an
absolute tolerance comparison.</p>
<h2 id="relative-tolerance-comparison-1"><a class="header" href="#relative-tolerance-comparison-1">Relative tolerance comparison</a></h2>
<pre><code>r1st &lt;= tol
r2nd &lt;= tol
rmax &lt;= tol
rmin &lt;= tol
</code></pre>
<p>A check to see how far apart two expressions are by comparing the absolute
difference between them to an tolerance that is scaled to the granularity of
one of the inputs. Mathematically, this is:</p>
<pre><code>|a - b| &lt;= func(|a|, |b|) * tol
</code></pre>
<p>Equivalent to, using <code>f32</code> as an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn float_eq_relative(a: f32, b: f32, tol: f32) -&gt; bool {
    // the PartialEq check covers equality of infinities
    a == b || {
        let chosen = func(a.abs(), b.abs());
        (a - b).abs() &lt;= (chosen * tol)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Where <code>func</code> is one of:</p>
<ul>
<li><code>r1st</code>: the first input (<code>a</code>)</li>
<li><code>r2nd</code>: the second input (<code>b</code>)</li>
<li><code>rmax</code>: the larger magnitude (aka <code>rel</code> for legacy reasons)</li>
<li><code>rmin</code>: the smaller magnitude</li>
</ul>
<p>If you are checking for equality versus an expected normal floating point value
then you may wish to calculate the tolerance based on that value and so using
<code>r1st</code> or <code>r2nd</code> will allow you to select it. If you are generally testing two
normal floating point values then <code>rmax</code> is a good general choice. If either
number may also be subnormal or close to zero, then you may need to calculate a
tolerance based on an intermediate value for an absolute tolerance check
instead.</p>
<p>Choice of <code>tol</code> will depend on the tolerances inherent in the specific
mathematical function or algorithm you have implemented. Note that a tolerance
of <code>n * EPSILON</code> (e.g. <code>f32::EPSILON</code>) will test that two expressions are within
<code>n</code> representable values of another. However, you should be aware that the
errors inherent in your inputs and calculations are likely to be much greater
than the small rounding errors this form would imply.</p>
<h2 id="units-in-the-last-place-ulps-comparison"><a class="header" href="#units-in-the-last-place-ulps-comparison">Units in the Last Place (ULPs) comparison</a></h2>
<pre><code>ulps &lt;= tol
</code></pre>
<p>A check to see how far apart two expressions are by comparing the number of
representable values between them. This works by interpreting the bitwise
representation of the input values as integers and comparing the absolute
difference between those. Equivalent to, using <code>f32</code> as an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn float_eq_ulps(a: f32, b: f32, tol: u32) -&gt; bool {
    if a.is_nan() || b.is_nan() {
        false // NaNs are never equal
    } else if a.is_sign_positive() != b.is_sign_positive() {
        a == b // values of different signs are only equal if both are zero.
    } else {
        let a_bits = a.to_bits();
        let b_bits = b.to_bits();
        let max = a_bits.max(b_bits);
        let min = a_bits.min(b_bits);
        (max - min) &lt;= tol
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Thanks to a deliberate quirk in the way the <a href="https://randomascii.wordpress.com/2012/01/23/stupid-float-tricks-2/">underlying format</a> of IEEE floats
was designed, this is a measure of how near two values are that scales with
their relative granularity. Note that <code>tol</code> is an unsigned integer, so for
example <code>ulps &lt;= 4</code> means <em>&quot;check that a and b are equal to within a distance of
four or less representable values&quot;</em>.</p>
<p>ULPs comparisons are very similar to relative tolerance checks, and as such are
useful for testing equality of normal floats but not for comparisons with zero
or infinity. Additionally, because floats use their most significant bit to
indicate their sign, ULPs comparisons are not valid for comparing values with
different signs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>An assortment of articles, papers and books that provide insight into how to approach floating point numerics and error analysis.</p>
<ul>
<li><a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html">The Art of Computer Programming Vol. 2: Seminumerical Algorithms, p214-283</a> - on the accuracy of floating point.</li>
<li><a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">Comparing Floating Point Numbers, 2012 Edition</a> - the rest of this series is very good, too.</li>
<li><a href="https://blog.m-ou.se/floats/">Converting Integers to Floats Using Hyperfocus</a></li>
<li><a href="https://blog.demofox.org/2017/11/21/floating-point-precision/">Demystifying Floating Point Precision</a></li>
<li><a href="https://www.exploringbinary.com/floating-point-questions-are-endless-on-stackoverflow-com/">Floating-Point Questions Are Endless on stackoverflow.com</a></li>
<li><a href="https://matthew-brett.github.io/teaching/floating_error.html">Floating point error</a></li>
<li><a href="https://evanw.github.io/float-toy/">Float toy</a> - a fantastic little demo page for gaining an insight into what the bits in a floating point number represent.</li>
<li><a href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/">IEEE Standard 754 Floating Point Numbers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interval_arithmetic">Interval arithmetic</a></li>
<li><a href="https://en.wikipedia.org/wiki/Loss_of_significance">Loss of significance</a></li>
<li><a href="https://people.eecs.berkeley.edu/~wkahan/Triangle.pdf">Miscalculating Area and Angles of a Needle-like Triangle</a></li>
<li><a href="https://epubs.siam.org/doi/book/10.1137/1.9780898718072">Numerical Computing with IEEE Floating Point Arithmetic</a></li>
<li><a href="https://en.wikipedia.org/wiki/Numerical_stability">Numerical Stability</a></li>
<li><a href="https://github.com/mockingbirdnest/Principia/wiki/On-the-dynamical-stability-of-Principia&#x27;s-modified-Jool-system">On the dynamical stability of Principia's modified Jool system</a></li>
<li><a href="http://marc-b-reynolds.github.io/math/2019/02/06/Posit1.html">Posit: thin triangle other tricks (REVEALED!)</a></li>
<li><a href="https://home.iitk.ac.in/~pranab/ESO208/rajesh/03-04/Errors.pdf">Round-off/Truncation Errors &amp; Numerical Cancellation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sterbenz_lemma">Sterbenz lemma</a></li>
<li><a href="https://en.wikipedia.org/wiki/Truncation_error">Truncation error</a></li>
<li><a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a> - a comprehensive mathematical treatment.</li>
<li><a href="https://floating-point-gui.de/">What Every Programmer Should Know About Floating-Point Arithmetic</a> - a useful introductory guide with cheat sheets for common programming languages.</li>
<li><a href="https://nhigham.com/2020/08/04/what-is-numerical-stability/">What is Numerical Stability?</a></li>
<li><a href="https://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/">Why 0.1 Does Not Exist In Floating-Point</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-documentation"><a class="header" href="#api-documentation">API documentation</a></h1>
<p>The latest API documentation is available <a href="../doc/float_eq/index.html">here</a> or at <a href="https://docs.rs/float_eq/">docs.rs</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
